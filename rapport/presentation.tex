\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphics}
\usepackage{framed}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usetheme{Warsaw}

\title[Support pour Verificarlo]{Support de MPI/OpenMP et de la vectorisation dans Verificarlo}
\subtitle{Master Calcul Haute Performance et Simulation}

\author[Hery, Ali, Nicolas]{Hery ANDRIANANTENAINA \\ Ali LAKBAL \\ Nicolas BOUTON}

\institute{\textbf{Encadrant:} Eric PETIT}

\date{Année 2020-2021}

\begin{document}

\maketitle

\begin{frame}{Verificarlo}
    \begin{block}{Compilateur de base pour verificarlo}
      \begin{itemize}
          \item CLANG
          \item LLVM
      \end{itemize}
    \end{block}
  \begin{block}{Domaine d'utilisation de verificarlo}
    Verificarlo permet par instrumentation des opérations flottantes, de pouvoir déboguer les erreurs, dû à la précision machine.
  \end{block}
  \begin{block}{Vectorisation dans le calcul scientifique}
    Jeux d'instruction 
        \begin{itemize}
            \item 128 = sse
            \item 256 = avx
            \item 512 = avx512
        \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Verificarlo}
    \begin{block}{Compilation}
      \begin{figure}
          \centering
          \includegraphics[width=6cm,height=4cm]{compilation.png}
          \caption{Fonctionnement de base d'un compilateur}
          \label{fig:my_label}
      \end{figure}
    \end{block}
\end{frame}

\begin{frame}{Verificarlo}
    \begin{block}{Compilation pour verificarlo}
      \begin{figure}
          \centering
          \includegraphics[width=6cm,height=6cm]{verificarlo_works.png}
          \caption{Fonctionnement de verificarlo}
          \label{fig:my_label}
      \end{figure}
    \end{block}
\end{frame}

\begin{frame}{Définition de certains termes techniques}
      \begin{itemize}
          \item probes : Les probes sont des fonctions implémenté dans vfcwrapper qui est linker avec le programme par la partie compilation de verificarlo.
          \item backend : Dans le cadre de verifcarlo, c’est la/les librairie(s) dynamique(s) qui seront appelées par le wrapper dans les probes. Dans le cadre d’un compilateur c’est la derniere phase qui descend de la représentation intermédiaire vers le binaires
          \item wrapper : Ce sont des fonctions qui enveloppent l’appel à d’autres fonctions.
          \item link : Il s’agit de la phase de compilation qui consiste à aller chercher toute les librairies externes appelé par l’application pour les liées au programme utilisateur afin de résoudre les références non défini.
          \item sérialisation : Dans le contexte de l’utilisation de vecteur il s’agit d’exécuter en séquence les éléments du vecteur.
      \end{itemize}
\end{frame}

\begin{frame}{Support MPI/openMP}
    \begin{block}{Notion indispensable pour le parallélisme}
      \begin{itemize}
          \item Système à mémoire partage
            \begin{itemize}
                \item SMP
                \item NUMA
            \end{itemize}
          \item Système à mémoire distribuée
          \item Thread ou flot d'exécution
          \item Processus
          \Calcul parallèle
      \end{itemize}
    \end{block}
    
    \begin{block}{Présentation d'open MPI}
      \begin{itemize}
          \item Installation : source: https://www.open-mpi.org/software/ompi/v4.1/
          \item Configuration : ./configure --prefix='/chemin/bin'
          \item Compilation : \textbf{make}
          \item Installation : \textbf{sudo make install}
          \item Préparation de l'environnement : 
      \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Présentation d'open MPI}
    \begin{block}{Description de communication dans Open MPI}
      \begin{itemize}
          \item l’environnement d’exécution
          \item les communication point à point
          \item les communication collectives
          \item les groupes de processus
          \item les topologies de processus
      \end{itemize}
    \end{block}
    
    \begin{block}{Compilation d’un programme parallèle avec verificarlo}
      \textbf{CC=OMPI\_CC=verificarlo mpicc}
    \end{block}
\end{frame}

\begin{frame}{Vectorisation}
\textbf{1.Introduction :}
  \begin{itemize}
        \item \textbf{Compilateur:} \textit{ Clang et gcc} 
        \item \textbf{probleme:} \textit{ Etant donné que notre encadrant nous a dit que le support de
gcc était éphémère dû à une dépendance avec fortran}
         \item \textbf{solutions : } \textit{supporter les types vectoriels de clang et non pas ceux de gcc. }
         \item \textbf{test: } \textit{ pour tester il faut bien configurer \textbf{verificarlo} avec \textbf {clang} pour le C et C++ avec la commande suivante : }
         \end{itemize}
         \begin{center}
        \textbf{\color{blue} ./configure --without-flang CC=clang CXX=clang++ }      
          \end{center}
     
    
\end{frame}

\begin{frame}{Vectorisation}
\textbf{2.Tests :}
  \begin{itemize}
        \item\textit{ Suivre le fonctionnement de test que
Verificarlo a commencé à implémenter. } 
         \item\textit{Nous avont testé si les résultats obtenus lors de la compilation et de l’exécution sont exactes.} 
        
         \item \textit{Les tests sont principale-
ment écrient en bash, avec un code de test écris en c et un code python}  
         \item \textit{Les tests se trouvent dans
le répertoire \textbf{ tests/test-vector-instrumentation/}.} 
         \end{itemize}
\end{frame}


\begin{frame}{Vectorisation}
\textbf{2.Tests :}
  \begin{itemize}
        \item\textit{Donc en genéral nous avons effectué des tests sur les operations arithmetique vectorielles avec les jeux d'instruction sse ,avx et avx512, et s'assurer du bon fonctionnement. } 
         \item\textit{Nous avont testé si les résultats obtenus lors de la compilation et de l’exécution sont exactes.} 
        
         \item \textit{Nous avos efféctué trois sous tests : le bon resultat des opérations vectorielles ,l'appel aux probes vectorielles et l'utilisation des jeux d'instructions vectorielles .}  
         
         \end{itemize}
         \end{frame}
\begin{frame}{Vectorisation}         
\textbf{2.1:le bon resultat des opérations vectorielles}
  \begin{itemize}
        \item\textit{Dans ce cas nous avons testé sur les differents backends, les differentes operation vectorielles avec les vecteurs de taille differente sur les précisions qu'on a choisit (float et double);
        et on a deduit que les résultats retournés sont vrai
        } 
        \end{itemize}
\end{frame}

\begin{frame}{Vectorisation}         
\textbf{2.2:l'appel des probes vectorielles}
  \begin{itemize}
        \item\textit{Nous avons généré le fichier intermédiaire pendant la compilation avec la commande : \textbf{\color{blue} –save-temps }
        \item\textit{une foit le fichier généré , on remarque que on a effectivement fait appel à notre probe vectorielle}
        
        } 
        \end{itemize}
        
\end{frame}

\begin{frame}{Vectorisation}         
\textbf{2.3:Utilisation des jeux d’instructions vectorielles}
  \begin{itemize}
     \item\textit{Dans verificarle, les instructions vectorielles pour les opérations arithmetiques sont présentées par la concaténation suivante :operation##vectoriel##précision } 
      \item\textit{elle s'utilise sur les registres \textbf{xmm,ymm,zmm } associés respectivement au jeux d'instructions \textbf{sse,avx,avx512} } 
      \textit{si on prend comme exemple : \textbf{mulps} avec un registre \textbf{xmm} c'est une instruction vectorisée} 
   \end{itemize}
\end{frame}

\begin{frame}{Vectorisation}         

  \begin{itemize}
   \item\textit{les vecteurs 256 et 512 bits sont déja inclus et supportés} 
   \item\textit{Dans la premieres version de verificarlo , les probes vecctorielles sont implémentées mais elles appelent toujours la version scalaire.donc de notre coté on a rajouté des fonction vectorielles dans les backends que nous avont appelé à partir des wrappers dans les probes,dans le fichier \textbf{src/vfcwrapper/main.c} } 
   \end{itemize}
\end{frame}

\begin{frame}{Vectorisation}         

  \begin{itemize}
  \item\textit{ensuite il faut ajouter les fonctions vectorielles dans l'interface qui se trouve dans le fichier \textbf{src/common/interflop.h}} 
 \item\textit{Nous avons cherché et tésté comment minimiser le nombre des fonction ,donc la meilleur solution q'uon a trouvé est de mettre la taille des vecteur en paramétre; ca nous a minimisé le nombre à 8 fonctions vectorielles en tout}
 \item\textit{Comme nous passons la taille en argument, il faudra tester la taille pour permettre à clang d’effectuer une opération vectorielle en changeant le type de notre tableau dans le bon type vectorielles de clang.}
 
 \item\textit{De plus nous avons déplacés la définitions des types vectorielles dans le fichier src/common/inteflop.h .}
   \end{itemize}
\end{frame}
\begin{frame}{Changements aux niveaux des backends}

  \begin{block}{Fonctions vectorielles en mode scalaire}
    Tous les backends
  \end{block}

  \begin{block}{Fonctions vectorielles en mode vectoriel}
    \begin{itemize}
    \item ieee
    \item vprec
    \end{itemize}
  \end{block}

\end{frame}

\begin{frame}{Changements aux niveaux du backend vprec}

  \begin{block}{Fonctionnement du backend}
    \begin{itemize}
    \item norme IEEE754
    \item fonction de debug
    \end{itemize}
  \end{block}

  \begin{block}{Opérande constantes}
    \begin{itemize}
    \item avertissement de clang sur les types des paramètres de fonction
    \item ajout d'un pragma pour retirer l'avertissement
    \end{itemize}
  \end{block}

\end{frame}

\begin{frame}{Changements aux niveaux du backend vprec}

  \begin{block}{Fonctionnement du backend}
    \begin{itemize}
    \item nombres fini et infini
    \item nombres normaux et dénormaux
    \end{itemize}
  \end{block}

  \begin{figure}
    \centering
    \includegraphics[width=200px]{../ressources/IEEE754_simple_precision.png}
    \caption{\label{fig:ieee_simple_precision}Représentation d'un nombre flottant simple précision}
  \end{figure}

\end{frame}

\begin{frame}{Compilation}

  \begin{block}{Ajout dans verificarlo}
    Compilation des \textbf{wrappers} et des \textbf{backends} avec le drapeau
    \textbf{-march=native}
  \end{block}

\end{frame}

\begin{frame}{Problèmes rencontrés}

  \begin{block}{Types vectorielles}
    Vecteur de 4 double précision
  \end{block}

  \begin{block}{Jeu d'instruction disponnible}
    SSE
  \end{block}

  \begin{block}{Clang}
    Utilise 4 addition vectoriel SSE
  \end{block}

  \begin{block}{Verificarlo}
    \begin{itemize}
    \item Backend: vectorisé comme pour clang
    \item Problème: vecteur passé par registre entre les modules
    \end{itemize}
  \end{block}

\end{frame}

\begin{frame}{Conclusion}

  \begin{block}{Cours en relation}
    Architecture Parallèle
  \end{block}

\end{frame}

\end{document}
